
* [Bugs](#bugs)
	* [[x] 输入字符串后, 莫名奇妙地在字符串前方多出奇怪字符: 需要添加偏移量修正地址,才能取到正确的字符串](#x-输入字符串后-莫名奇妙地在字符串前方多出奇怪字符-需要添加偏移量修正地址才能取到正确的字符串)
		* [解决方法](#解决方法)
		* [体会](#体会)
	* [当数据段姓名为用户键入字符串子串时，会误将两者视为相等字符串](#当数据段姓名为用户键入字符串子串时会误将两者视为相等字符串)
		* [解决方法](#解决方法-1)

## Bugs

### [x] 输入字符串后, 莫名奇妙地在字符串前方多出奇怪字符: 需要添加偏移量修正地址,才能取到正确的字符串

#### 解决方法

进行10号 dos 系统调用时，dx 对应数据段内存单元应定义如下:

```asm
data segment use16
    buf db 100
    db ?
    db 50 dup(0)
```

其中，第一个字节单元为字符串可用总长度，第二个字节单元为字符串当前实际长度，从第三个字节单元起为真正的字符串存放处.由于这种特殊约定，当成功将用户输入字符串成功存放至数据段内存单元后，若要取出目标字符串，其偏移地址应为`bx = offset buf + 2`.

简而言之: 系统调用时 - `dx = offset buf`; 取字符串时 - `bx = offset buf + 2`.

#### 体会

-   通过单步调试排除bug,加深了 Turbo Debugger 的理解与应用，在不了解10号调用的机制前，仍然成功排除了Bug(尽管不清楚bug产生的具体原因)
-   通过理论课程的学习，加深了10号系统调用的工作机制: 通过10号系统调用读入用户字符串后，前2个字节单元分别存放字符串可用总长度及当前实际长度,实际字符串首址应为第三个字节单元

### 当数据段姓名为用户键入字符串子串时，会误将两者视为相等字符串

#### 解决方法

```asm
CMP     DL, 0     ; 如果缓冲区姓名已结束,说明查找成功
JE      CAL        
```

修改为

```asm
CMP     DL, 0       ; 如果缓冲区姓名已结束,说明可能查找成功
JE      ZERO        ; 验证用户键入字符串是否也结束

...

ZERO:   CMP     BYTE PTR DS:[BP + SI], 24H   ; 检查数据段姓名是否为用户输入字符串的子串
JE      CAL         ; 不是子串，说明查找成功，跳转至平均成绩计算处
JMP     COMPA       ; 是子串，说明查找失败，继续比较下一个学生姓名
```
